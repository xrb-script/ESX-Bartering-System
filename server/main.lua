-- [[ xrb-Bartering - Main Script ]]
local ESX = nil
ESX = exports["es_extended"]:getSharedObject()

local currentPedLocationIndex = 1
local contractsCompletedAtCurrentLocation = 0
local playerActiveContracts = {} -- [source] = { contractId, contractData, endTime, identifier }
local currentShopStock = {} -- [shopId] = { {name, price, currency, stock}, ... }
local shopRefreshTimer = nil

-- [[ Database Functions (ESX - identifier - Rev 4) ]]
local function getDbPlayerData(identifier) if not identifier then return { points = 0, cancel_streak = 0 } end; local result = MySQL.single.await('SELECT points, cancel_streak FROM player_bartering_points WHERE identifier = ?', { identifier }); if result then result.points = tonumber(result.points) or 0; result.cancel_streak = tonumber(result.cancel_streak) or 0 else result = { points = 0, cancel_streak = 0 } end; return result end
local function updateDbPlayerData(identifier, newPoints, newStreak) if not identifier then return end; local pointsToSet = newPoints; local streakToSet = newStreak; local currentData; if pointsToSet == nil or streakToSet == nil then currentData = getDbPlayerData(identifier); if pointsToSet == nil then pointsToSet = currentData.points end; if streakToSet == nil then streakToSet = currentData.cancel_streak end end; pointsToSet = math.max(0, tonumber(pointsToSet) or 0); streakToSet = math.max(0, tonumber(streakToSet) or 0); MySQL.update.await('INSERT INTO player_bartering_points (identifier, points, cancel_streak) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE points = VALUES(points), cancel_streak = VALUES(cancel_streak)', { identifier, pointsToSet, streakToSet }); return pointsToSet end
local function addDbPlayerPoints(identifier, pointsToAdd) if not identifier then return 0 end; local currentData = getDbPlayerData(identifier); local newPoints = currentData.points + pointsToAdd; return updateDbPlayerData(identifier, newPoints, nil) end
local function setDbPlayerPoints(identifier, points) if not identifier then return end; updateDbPlayerData(identifier, points, nil) end
local function resetDbPlayerCancelStreak(identifier) if not identifier then return end; updateDbPlayerData(identifier, nil, 0) end
local function incrementDbPlayerCancelStreak(identifier) if not identifier then return 0 end; local currentData = getDbPlayerData(identifier); local newStreak = currentData.cancel_streak + 1; updateDbPlayerData(identifier, nil, newStreak); return newStreak end

-- [[ Contract Ped Functions ]]
local function loadPedState() local indexResult = MySQL.scalar.await('SELECT state_value FROM bartering_system_state WHERE state_key = ?', {'current_location_index'}); local contractsResult = MySQL.scalar.await('SELECT state_value FROM bartering_system_state WHERE state_key = ?', {'contracts_at_location'}); currentPedLocationIndex = indexResult and tonumber(indexResult) or 1; contractsCompletedAtCurrentLocation = contractsResult and tonumber(contractsResult) or 0; print(('[xrb-Bartering] Ped State Loaded: Location Index %s, Contracts at Location %s'):format(currentPedLocationIndex, contractsCompletedAtCurrentLocation)) end
local function savePedState() MySQL.update.await('INSERT INTO bartering_system_state (state_key, state_value) VALUES (?, ?) ON DUPLICATE KEY UPDATE state_value = ?', {'current_location_index', currentPedLocationIndex, currentPedLocationIndex}); MySQL.update.await('INSERT INTO bartering_system_state (state_key, state_value) VALUES (?, ?) ON DUPLICATE KEY UPDATE state_value = ?', {'contracts_at_location', contractsCompletedAtCurrentLocation, contractsCompletedAtCurrentLocation}) end
local function movePedToNextLocation() currentPedLocationIndex = currentPedLocationIndex + 1; if currentPedLocationIndex > #Config.PedLocations then currentPedLocationIndex = 1 end; contractsCompletedAtCurrentLocation = 0; savePedState(); print(('[xrb-Bartering] Contract Ped moved to location index %s. Triggering client update.'):format(currentPedLocationIndex)); TriggerClientEvent('xrb-bartering:updatePedLocation', -1, currentPedLocationIndex) end

-- [[ Contract Functions ]]
local function getAvailableContract(playerPoints) local availableTiers = {}; for pointsRequired, contracts in pairs(Config.ContractTiers) do if playerPoints >= pointsRequired then table.insert(availableTiers, { points = pointsRequired, contracts = contracts }) end end; if #availableTiers == 0 then return nil end; table.sort(availableTiers, function(a, b) return a.points > b.points end); local selectedTier = availableTiers[1]; if not selectedTier.contracts or #selectedTier.contracts == 0 then print(('[xrb-Bartering] [WARNING] Selected contract tier (Points >= %d) has no contracts defined!'):format(selectedTier.points)); return nil end; local randomIndex = math.random(1, #selectedTier.contracts); return selectedTier.contracts[randomIndex] end
local function startContractTimer(source, contractId) local contractInfo = playerActiveContracts[source]; if not contractInfo then return end; CreateThread(function() local endTime = contractInfo.endTime; while GetGameTimer() / 1000 < endTime do Wait(1000); local xPlayer = ESX.GetPlayerFromId(source); if not xPlayer or not playerActiveContracts[source] or playerActiveContracts[source].contractId ~= contractId then break end end; if playerActiveContracts[source] and playerActiveContracts[source].contractId == contractId then local xPlayer = ESX.GetPlayerFromId(source); if xPlayer then local pointsLost = Config.PointsPenaltyFail; addDbPlayerPoints(xPlayer.identifier, -pointsLost); print(('[xrb-Bartering] Contract %s for player %s (%s) FAILED due to time limit. Lost %d points.'):format(contractId, source, xPlayer.identifier, pointsLost)); TriggerClientEvent('ox_lib:notify', source, { title = 'Contract Failed', description = Config.Messages['contract_failed_time']:format(pointsLost), type = 'error' }); TriggerClientEvent('xrb-bartering:contractFailed', source) end; playerActiveContracts[source] = nil end end) end

-- [[ Shop Functions ]]
local function GenerateShopStock(shopId) local shopConfig = nil; for _, shop in ipairs(Config.Shops) do if shop.id == shopId then shopConfig = shop; break end end; if not shopConfig or not shopConfig.potential_items then print(('[xrb-Bartering] [ERROR] No config/items found for shop %s.'):format(shopId)); currentShopStock[shopId] = {}; return false end; local generatedStock = {}; for _, itemData in ipairs(shopConfig.potential_items) do if math.random(1, 100) <= itemData.chance then local stockAmount = math.random(itemData.min_stock, itemData.max_stock); if stockAmount > 0 then table.insert(generatedStock, { name = itemData.name, price = itemData.base_price, currency = itemData.currency == 'bank' and 'bank' or 'cash', stock = stockAmount }) end end end; currentShopStock[shopId] = generatedStock; return true end
local function RefreshAllShops() print(Config.Messages['shop_refreshing']); local allSuccess = true; local errorShops = {}; for _, shopConfig in ipairs(Config.Shops) do if not GenerateShopStock(shopConfig.id) then allSuccess = false; table.insert(errorShops, shopConfig.id) end end; if allSuccess then print(Config.Messages['shop_refreshed']) else print(("[xrb-Bartering] [ERROR] Shop refresh completed with errors in shops: %s"):format(table.concat(errorShops, ", "))) end; StartShopRefreshTimer() end
function StartShopRefreshTimer() if shopRefreshTimer then ClearTimeout(shopRefreshTimer); shopRefreshTimer = nil end; local intervalMs = Config.ShopRefreshIntervalMinutes * 60 * 1000; if intervalMs > 0 then shopRefreshTimer = SetTimeout(intervalMs, RefreshAllShops) else print('[xrb-Bartering] Automatic shop refresh is disabled.') end end

-- [[ Core Events ]]
AddEventHandler('onResourceStart', function(resourceName) if resourceName == GetCurrentResourceName() then SetTimeout(3000, function() if not ESX then print("[xrb-Bartering] ERROR: ESX not ready on start!"); return end; loadPedState(); print('[xrb-Bartering] Generating initial shop stock...'); for _, shopConfig in ipairs(Config.Shops) do GenerateShopStock(shopConfig.id) end; StartShopRefreshTimer(); print('[xrb-Bartering] Server resource started for ESX.') end) end end)
AddEventHandler('onResourceStop', function(resourceName) if resourceName == GetCurrentResourceName() then savePedState(); if shopRefreshTimer then ClearTimeout(shopRefreshTimer); shopRefreshTimer = nil; print('[xrb-Bartering] Shop refresh timer stopped.') end; print('[xrb-Bartering] Server resource stopped.') end end)

-- ==============================
-- [[ Network Events (ESX) ]]
-- ==============================
RegisterNetEvent('xrb-bartering:requestContract', function() local source = source; local xPlayer = ESX.GetPlayerFromId(source); if not xPlayer then return end; if playerActiveContracts[source] then TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['already_active_contract'], type = 'error' }); return end; local playerPoints = getDbPlayerData(xPlayer.identifier).points; local contractData = getAvailableContract(playerPoints); if not contractData then TriggerClientEvent('ox_lib:notify', source, { title = 'Information', description = Config.Messages['no_contracts_available_for_tier'], type = 'info' }); return end; if contractData.points_reward == nil then contractData.points_reward = 0 end; local contractId = ('contract_%s_%s'):format(source, math.random(1000, 9999)); local currentTime = GetGameTimer() / 1000; local endTime = currentTime + (contractData.time_limit * 60); playerActiveContracts[source] = { contractId = contractId, contractData = contractData, endTime = endTime, identifier = xPlayer.identifier }; TriggerClientEvent('xrb-bartering:contractInfo', source, playerActiveContracts[source]); TriggerClientEvent('ox_lib:notify', source, { title = 'Contract Accepted', description = Config.Messages['contract_accepted']:format(contractData.name, contractData.time_limit), type = 'success' }); startContractTimer(source, contractId) end)
RegisterNetEvent('xrb-bartering:submitItems', function() local source = source; local xPlayer = ESX.GetPlayerFromId(source); if not xPlayer then return end; local activeContract = playerActiveContracts[source]; if not activeContract then TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['no_active_contract'], type = 'error' }); return end; if not activeContract.contractData then print(('[xrb-Bartering] [CRITICAL ERROR] submitItems: activeContract.contractData is nil for player %s'):format(source)); playerActiveContracts[source]=nil; TriggerClientEvent('xrb-bartering:contractFailed', source); return end; local hasAllItems = true; local itemsToRemove = {}; local missingItemText = ""; if not activeContract.contractData.required_items then activeContract.contractData.required_items = {} end; for _, req in ipairs(activeContract.contractData.required_items) do local itemInfo = xPlayer.getInventoryItem(req.item); if not itemInfo or itemInfo.count < req.count then hasAllItems = false; local itemLabel = ESX.GetItemLabel(req.item) or req.item; missingItemText = string.format("Missing: %s (Needed: %d, Has: %d)", itemLabel, req.count, itemInfo and itemInfo.count or 0); TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['not_enough_items'] .. " (" .. missingItemText .. ")", type = 'error' }); break end; table.insert(itemsToRemove, { item = req.item, count = req.count }) end; if hasAllItems then for _, itemData in ipairs(itemsToRemove) do xPlayer.removeInventoryItem(itemData.item, itemData.count) end; local pointsRewardFromConfig = activeContract.contractData.points_reward; local pointsGained = 0; if pointsRewardFromConfig ~= nil then local convertedPoints = tonumber(pointsRewardFromConfig); if type(convertedPoints) == "number" then pointsGained = convertedPoints else print(('[xrb-Bartering] [WARNING] Invalid points_reward type (%s) for contract %s. Value: [%s]. Awarding 0 points.'):format(type(pointsRewardFromConfig), activeContract.contractData.name or 'N/A', tostring(pointsRewardFromConfig))) end else print(('[xrb-Bartering] [WARNING] Missing points_reward for contract %s. Awarding 0 points.'):format(activeContract.contractData.name or 'N/A')) end; local currentPoints = getDbPlayerData(xPlayer.identifier).points; local newTotalPoints = currentPoints + pointsGained; resetDbPlayerCancelStreak(xPlayer.identifier); print(('[xrb-Bartering] Cancel streak reset for player %s (%s) after successful contract.'):format(source, xPlayer.identifier)); local closedContractId = activeContract.contractId or 'N/A'; local closedContractName = activeContract.contractData.name or 'N/A'; local moneyReward = activeContract.contractData.black_money_reward; TriggerClientEvent('xrb-bartering:contractSuccess', source); playerActiveContracts[source] = nil; print(('[xrb-Bartering] Contract %s closed for player %s. Attempting to add %d points.'):format(closedContractId, source, pointsGained)); updateDbPlayerData(xPlayer.identifier, newTotalPoints, 0); local rewardNotifyTextPart = nil; if moneyReward and moneyReward.amount and moneyReward.amount > 0 then local moneyType = moneyReward.type; local amount = moneyReward.amount; if moneyType == 'cash' then xPlayer.addMoney(amount); rewardNotifyTextPart = string.format("$%s", amount) elseif moneyType == 'bank' then xPlayer.addBank(amount); rewardNotifyTextPart = string.format("$%s BANK", amount) elseif moneyType == 'black_money' then local blackMoneyItem = Config.BlackMoneyItemName; if blackMoneyItem and ESX.Items[blackMoneyItem] then if xPlayer.canCarryItem(blackMoneyItem, amount) then xPlayer.addInventoryItem(blackMoneyItem, amount); local itemLabel = ESX.GetItemLabel(blackMoneyItem) or blackMoneyItem; rewardNotifyTextPart = string.format("%sx %s", amount, itemLabel) else xPlayer.addMoney(amount); rewardNotifyTextPart = string.format("$%s", amount); print(('[xrb-Bartering] [WARNING] Failed add black money item %s (%sx) for contract %s (Player: %s). Giving CASH.'):format(blackMoneyItem, amount, closedContractName, source)) end else xPlayer.addMoney(amount); rewardNotifyTextPart = string.format("$%s", amount); print(('[xrb-Bartering] [WARNING] Black money item "%s" not found/configured for contract %s. Giving CASH.'):format(tostring(blackMoneyItem), closedContractName)) end else xPlayer.addMoney(amount); rewardNotifyTextPart = string.format("$%s", amount); print(('[xrb-Bartering] [WARNING] Unknown reward type "%s" for contract %s. Giving CASH.'):format(moneyType, closedContractName)) end end; local finalNotificationDescription = ""; local pointsGainedNum = pointsGained; if rewardNotifyTextPart then finalNotificationDescription = "Contract completed successfully! You earned " .. pointsGainedNum .. " points and " .. rewardNotifyTextPart .. "." else local success, formattedMsg = pcall(string.format, Config.Messages['contract_success_points'], pointsGainedNum); if success then finalNotificationDescription = formattedMsg else print(('[xrb-Bartering] [ERROR] Failed string.format for points success message. Points: %s, Error: %s'):format(tostring(pointsGainedNum), formattedMsg)); finalNotificationDescription = "Contract completed! Points: " .. pointsGainedNum end end; TriggerClientEvent('ox_lib:notify', source, { title = 'Success', description = finalNotificationDescription, type = 'success' }); contractsCompletedAtCurrentLocation = contractsCompletedAtCurrentLocation + 1; savePedState(); if contractsCompletedAtCurrentLocation >= Config.ContractsPerLocation then movePedToNextLocation() end end end)
RegisterNetEvent('xrb-bartering:requestShopAccess', function(shopId) local source = source; local xPlayer = ESX.GetPlayerFromId(source); if not xPlayer then return end; local shopConfig = nil; for _, shop in ipairs(Config.Shops) do if shop.id == shopId then shopConfig = shop; break end end; if not shopConfig then print(('[xrb-Bartering] [ERROR] Player %s tried shop %s - config not found.'):format(source, shopId)); TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = 'Store config error.', type = 'error' }); return end; local playerPoints = getDbPlayerData(xPlayer.identifier).points; if playerPoints >= shopConfig.required_points then local stockData = currentShopStock[shopId] or {}; TriggerClientEvent('xrb-bartering:openOxLibShop', source, shopConfig.label, stockData, shopId) else TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['not_enough_points_shop']:format(playerPoints, shopConfig.required_points), type = 'error' }) end end)
RegisterNetEvent('xrb-bartering:purchaseShopItem', function(shopId, itemName, itemPrice, currencyType) local source = source; local xPlayer = ESX.GetPlayerFromId(source); if not xPlayer then return end; local shopStock = currentShopStock[shopId]; local itemInStock = nil; local itemIndex = -1; if shopStock then for i, item in ipairs(shopStock) do if item.name == itemName then itemInStock = item; itemIndex = i; break end end end; if not itemInStock then print(('[xrb-Bartering] [ERROR] Purchase Fail: Item %s not in server stock for shop %s (Player: %s).'):format(itemName, shopId, source)); TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['shop_purchase_failed_stock'], type = 'error' }); return end; if itemInStock.stock <= 0 then TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['shop_purchase_failed_stock'], type = 'error' }); local csc = nil; for _, s in ipairs(Config.Shops) do if s.id == shopId then csc = s; break end end; if csc then TriggerClientEvent('xrb-bartering:openOxLibShop', source, csc.label, currentShopStock[shopId] or {}, shopId) end; return end; if itemInStock.price ~= itemPrice or itemInStock.currency ~= currencyType then print(('[xrb-Bartering] [SECURITY ALERT] Price mismatch item %s shop %s (Player: %s). Server: %s %s, Client: %s %s'):format(itemName, shopId, source, itemInStock.price, itemInStock.currency, itemPrice, currencyType)); TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['shop_purchase_failed_generic'], type = 'error' }); return end; if not xPlayer.canCarryItem(itemName, 1) then TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['shop_purchase_failed_inventory'], type = 'error' }); return end; local canAfford = false; if currencyType == 'bank' then if xPlayer.getBank() >= itemPrice then canAfford = true; xPlayer.removeBank(itemPrice) end else if xPlayer.getMoney() >= itemPrice then canAfford = true; xPlayer.removeMoney(itemPrice) end end; if canAfford then xPlayer.addInventoryItem(itemName, 1); currentShopStock[shopId][itemIndex].stock = currentShopStock[shopId][itemIndex].stock - 1; local itemLabel = ESX.GetItemLabel(itemName) or itemName; TriggerClientEvent('ox_lib:notify', source, { title = 'Successful Purchase', description = Config.Messages['shop_purchase_success']:format(itemLabel), type = 'success' }); local csc = nil; for _, s in ipairs(Config.Shops) do if s.id == shopId then csc = s; break end end; if csc then TriggerClientEvent('xrb-bartering:openOxLibShop', source, csc.label, currentShopStock[shopId], shopId) end else local moneyMsg = currencyType == 'bank' and Config.Messages['shop_purchase_failed_money_bank'] or Config.Messages['shop_purchase_failed_money_cash']; TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = moneyMsg, type = 'error' }) end end)
RegisterNetEvent('xrb-bartering:requestInitialState', function() local source = source; local xPlayer = ESX.GetPlayerFromId(source); if not xPlayer then return end; TriggerClientEvent('xrb-bartering:receiveInitialState', source, currentPedLocationIndex); if playerActiveContracts[source] then TriggerClientEvent('xrb-bartering:contractInfo', source, playerActiveContracts[source]) end end)
AddEventHandler('esx:playerDropped', function(playerId, reason) local source = playerId; if playerActiveContracts[source] then playerActiveContracts[source] = nil end end)
RegisterNetEvent('xrb-bartering:server:playerDied', function() local source = source; local xPlayer = ESX.GetPlayerFromId(source); if not xPlayer then return end; if Config.PointsPenaltyDeath and Config.PointsPenaltyDeath > 0 then local pointsLost = Config.PointsPenaltyDeath; addDbPlayerPoints(xPlayer.identifier, -pointsLost); TriggerClientEvent('ox_lib:notify', source, { title = 'Penalties', description = Config.Messages['points_lost_death']:format(pointsLost), type = 'warning' }) end end)

-- [[ COMMAND: /bartering Request Handler (ESX) ]]
RegisterNetEvent('xrb-bartering:requestStatusCommand', function() local source = source; local xPlayer = ESX.GetPlayerFromId(source); if not xPlayer then return end; local playerData = getDbPlayerData(xPlayer.identifier); local currentPoints = playerData.points; local activeContractInfo = playerActiveContracts[source]; local contractToSend = nil; if activeContractInfo and activeContractInfo.contractData then local points_reward = activeContractInfo.contractData.points_reward or 0; contractToSend = { contractData = { name = activeContractInfo.contractData.name or "Unknown", points_reward = points_reward, required_items = activeContractInfo.contractData.required_items or {} }, endTime = activeContractInfo.endTime } end; local statusData = { points = currentPoints, contract = contractToSend }; TriggerClientEvent('xrb-bartering:showStatusMenu', source, statusData) end)

-- [[ ADMIN MENU & COMMANDS (ESX) ]]
RegisterNetEvent('xrb-bartering:adminModifyPoints', function(targetPlayerId, action, amount) local source = source; local xPlayer = ESX.GetPlayerFromId(source); if not xPlayer then return end; if xPlayer.getGroup() ~= Config.AdminGroup then print(('[xrb-Bartering] [SECURITY] Player %s tried adminModifyPoints without permission.'):format(source)); return end; local targetXPlayer = ESX.GetPlayerFromId(targetPlayerId); if not targetXPlayer then TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['invalid_player'], type = 'error' }); return end; local amountNum = tonumber(amount); if not amountNum or amountNum < 0 then TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['invalid_amount'], type = 'error' }); return end; local targetIdentifier = targetXPlayer.identifier; local targetName = targetXPlayer.getName(); local adminName = xPlayer.getName(); local currentData = getDbPlayerData(targetIdentifier); local newTotalPoints = 0; local success = false; local actionText = ""; local newStreak = currentData.cancel_streak; if action == 'add' then newTotalPoints = currentData.points + amountNum; actionText = "added"; success = true elseif action == 'remove' then newTotalPoints = currentData.points - amountNum; actionText = "removed"; success = true elseif action == 'set' then newTotalPoints = amountNum; actionText = "set"; success = true else print(('[xrb-Bartering] [ERROR] Invalid action "%s" in adminModifyPoints from admin %s.'):format(action, source)); return end; if success then updateDbPlayerData(targetIdentifier, newTotalPoints, newStreak); print(('[xrb-Bartering] [ADMIN] %s (%s) %s %s points for %s (%s). New total: %s'):format(adminName, source, actionText, amountNum, targetName, targetPlayerId, math.max(0, newTotalPoints))); TriggerClientEvent('ox_lib:notify', source, { title = 'Success', description = Config.Messages['admin_points_success']:format(targetName, targetPlayerId), type = 'success' }); if action == 'add' then TriggerClientEvent('ox_lib:notify', targetPlayerId, { title = 'Bartering Points', description = Config.Messages['points_received']:format(amountNum), type = 'inform' }) elseif action == 'remove' then TriggerClientEvent('ox_lib:notify', targetPlayerId, { title = 'Bartering Points', description = Config.Messages['points_lost']:format(amountNum), type = 'warning' }) elseif action == 'set' then TriggerClientEvent('ox_lib:notify', targetPlayerId, { title = 'Bartering Points', description = Config.Messages['points_set_admin']:format(math.max(0, newTotalPoints)), type = 'inform' }) end else TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['admin_points_failed']:format(targetName, targetPlayerId), type = 'error' }) end end)
RegisterCommand('adminbartering', function(source, args, rawCommand) local xPlayer = ESX.GetPlayerFromId(source); if not xPlayer then return end; if xPlayer.getGroup() == Config.AdminGroup then local players = {}; local playerList = ESX.GetPlayers(); for i=1, #playerList do local ply = ESX.GetPlayerFromId(playerList[i]); if ply then table.insert(players, {source = playerList[i], name = ply.getName()}) end end; TriggerClientEvent('xrb-bartering:openAdminMenu', source, players) else TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['no_permission'], type = 'error' }) end end, true)
RegisterCommand('refreshbartershops', function(source, args, rawCommand) local xPlayer = ESX.GetPlayerFromId(source); if not xPlayer then return end; if xPlayer.getGroup() == Config.AdminGroup then print(('[xrb-Bartering] [ADMIN] %s (%s) forced a shop refresh.'):format(xPlayer.getName(), source)); RefreshAllShops(); TriggerClientEvent('ox_lib:notify', source, { title = 'Admin', description = 'Store stock was manually refreshed and timer reset.', type = 'inform' }) else TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['no_permission'], type = 'error' }) end end, true)

-- [[ Cancel Contract with Streak Logic (ESX) ]]
RegisterNetEvent('xrb-bartering:requestCancelContract', function() local source = source; local xPlayer = ESX.GetPlayerFromId(source); if not xPlayer then return end; local activeContract = playerActiveContracts[source]; if activeContract then local identifier = xPlayer.identifier; local currentData = getDbPlayerData(identifier); local currentStreak = currentData.cancel_streak; local currentPoints = currentData.points; local pointsPenaltyBase = Config.PointsPenaltyCancelBase or 0; local effectiveStreak = math.min(currentStreak, Config.MaxCancelStreakForPenalty or 5); local pointsPenalty = pointsPenaltyBase * (2 ^ effectiveStreak); local closedContractId = activeContract.contractId or 'N/A'; playerActiveContracts[source] = nil; local newPoints = currentPoints; local newStreak = incrementDbPlayerCancelStreak(identifier); if pointsPenalty > 0 then newPoints = currentPoints - pointsPenalty; updateDbPlayerData(identifier, newPoints, newStreak); print(('[xrb-Bartering] Player %s (%s) cancelled contract %s. Lost %d points (Streak: %s -> %s). New total: %s'):format(source, identifier, closedContractId, pointsPenalty, currentStreak, newStreak, math.max(0,newPoints))); TriggerClientEvent('ox_lib:notify', source, { title = 'Warning', description = Config.Messages['contract_cancelled_penalty_streak']:format(pointsPenalty, newStreak), type = 'warning' }) else print(('[xrb-Bartering] Player %s (%s) cancelled contract %s with no point penalty (Streak: %s -> %s).'):format(source, identifier, closedContractId, currentStreak, newStreak)); TriggerClientEvent('ox_lib:notify', source, { title = 'Contract Cancelled', description = Config.Messages['contract_cancelled_success'], type = 'info' }) end; TriggerClientEvent('xrb-bartering:contractFailed', source) else TriggerClientEvent('ox_lib:notify', source, { title = 'Error', description = Config.Messages['cannot_cancel_no_contract'], type = 'error' }) end end)